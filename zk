database update
60. 网管侧的enigineBoot必须比设备侧的小,停止后要等4，5分钟后重启

61. 查看SID,监听端口等信息:lsnrctl status

62. 查看数据文件路径:SELECT NAME,FILE#,STATUS,CHECKPOINT_CHANGE# "CHECKPOINT" FROM V$DATAFILE;



定义:分布式协调服务
CAP理论
可用性、一致性、分区容忍性，只能三选二。下面举例说明:
假设我们用一台服务器A对外提供存储服务，为了避免这台服务器宕机导致服务不可用，我们又在另外一台服务器B上运行了同样的存储服务。每次用户在往服务器A写入数据的时候，A都往服务器B上写一份，然后再返回客户端。一切都运行得很好，用户的每份数据都存了两份，分别在A和B上，用户访问任意一台机器都能读取到最新的数据。 
这时不幸的事情发生，A和B之间的网络断了导致A和B无法通信，也就是说网络出现了分区，那么用户在往服务器A写入数据的时候，服务器A无法将该数据写入到服务器B。这时，服务器A就必须要做出一个艰难的选择：
要么选择一致性(C)而牺牲可用性(A)：为了保证服务器A和B上的数据是一致的，服务器A决定暂停对外提供数据写入服务，从而保证了服务器A和B上的数据是一致，但是牺牲了可用性。 
注意：这里的可用性不是我们通常所说的高可用性(比如，服务器宕机导致服务不可用)，而是指服务器虽然活着，但是却不能对外提供写入服务。
要么选择可用性(A)而牺牲一致性(C)：为了保证服务不中断，服务器A先把数据写入到了本地，然后返回客户端，从而让客户端感觉数据已经写入了。这导致了服务器A和B上的数据就不一致了。

分布式系统无法放弃网络分区容忍性
网络分区准确地说是指两台机器无法在期望的时间内完成数据交换。这不仅仅是指两台机器之间的网络完全断开了,还可能有其他情况产生网络分区，比如对方机器宕机了，网络延时等情况。因此，在分布式系统中，通常是无法放弃Partition Tolerance的，也就只能在CP和AP之间做选择了。如果有个分布式系统号称是CA的，那一定是扯淡。
可用性和一致性的选择
可用性和一致性之间的选择不是非此即彼的，而是根据业务的需求在它们两者之间做妥协。比如，我们可以放弃对强一致性的追求，让其变成最终一致性，也就是说当服务器A不能把数据传给服务器B时，它先将数据缓存在其本地，等到网络恢复以后再将数据传给服务器B。这样，服务还是可用的，只是在一定的时间窗口内两者的数据是不一致的。


Zookeeper数据模型
ZooKeeper的数据结构, 与普通的文件系统极为类似，Zookeeper中每个节点称为一个znode. 每个znode由3部分组成:
•	stat. 此为状态信息, 描述该znode的版本,时间戳、权限等信息.
•	data. 与该znode关联的数据.
•	children. 该znode下的子节点.

节点状态主要包括Zxid（ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生. 创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加）、timeStamp等

Zookeeper节点类型

1.	persistent. 
persistent节点不和特定的session绑定, 不会随着创建该节点的session的结束而消失, 而是一直存在, 除非该节点被显式删除.
2.	ephemeral. 
ephemeral节点是临时性的, 如果创建该节点的session结束了, 该节点就会被自动删除. ephemeral节点不能拥有子节点. 虽然ephemeral节点与创建它的session绑定, 但只要该该节点没有被删除, 其他session就可以读写该节点中关联的数据. 使用-e参数指定创建ephemeral节点.
3.	sequence. 
严格的说, sequence并非节点类型中的一种. sequence节点既可以是ephemeral的, 也可以是persistent的. 创建sequence节点时, ZooKeeper server会在指定的节点名称后加上一个数字序列, 该数字序列是递增的. 因此可以多次创建相同的sequence节点, 而得到不同的节点. 使用-s参数指定创建sequence节点.

watch
watch的意思是监听感兴趣的事件. 在命令行中, 以下几个命令可以指定是否监听相应的事件.
ls命令. ls命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的子节点的增减, 以及该znode本身的删除事件.
get命令. get命令的第一个参数指定znode, 第二个参数如果为true, 则说明监听该znode的更新和删除事件
watcher的特点:
1. 注册只能确保一次消费
无论是服务端还是客户端，一旦一个 Watcher 被触发，ZooKeeper 都会将其从相应的存储中移除。因此，开发人员在 Watcher 的使用上要记住的一点是需要反复注册。这样的设计有效地减轻了服务端的压力。如果注册一个 Watcher 之后一直有效，那么针对那些更新非常频繁的节点，服务端会不断地向客户端发送事件通知，这无论对于网络还是服务端性能的影响都非常大。
2. 客户端串行执行
客户端 Watcher 回调的过程是一个串行同步的过程，这为我们保证了顺序，同时，需要开发人员注意的一点是，千万不要因为一个 Watcher 的处理逻辑影响了整个客户端的 Watcher 回调。
3. 轻量级设计
WatchedEvent 是 ZooKeeper 整个 Watcher 通知机制的最小通知单元，这个数据结构中只包含三部分的内容：通知状态、事件类型和节点路径。也就是说，Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。例如针对 NodeDataChanged 事件，ZooKeeper 的 Watcher 只会通知客户指定数据节点的数据内容发生了变更，而对于原始数据以及变更后的新数据都无法从这个事件中直接获取到，而是需要客户端主动重新去获取数据，这也是 ZooKeeper 的 Watcher 机制的一个非常重要的特性。另外，客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象传递到服务端，仅仅只是在客户端请求中使用 boolean 类型属性进行了标记，同时服务端也仅仅只是保存了当前连接的 ServerCnxn 对象。这样轻量级的 Watcher 机制设计，在网络开销和服务端内存开销上都是非常廉价的。

ZooKeeper Sessions
 


